ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ
УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


Кафедра «Програмної інженерії»


ЗВІТ
з лабораторної роботи  № 2
з дисципліни «Аналіз та рефакторінг коду»



Виконав					                 Прийняв: Дашенков Д. С.
ст. гр. ПЗПІ-22-5
Білоус Микола Олексійович







Харків 2024


 
2. РОЗРОБКА БАЗИ ДАНИХ ДЛЯ СЕРВЕРНОЇ ЧАСТИНИ ПРОГРАМНОЇ СИСТЕМИ ТА ПРИКЛАДНОГО ПРОГРАМНОГО ІНТЕРФЕЙСУ (API)

2.1 Мета: розробити базу даних для серверної частини  програмної системи та прикладний програмний інтерфейс.

2.2 Хід роботи:
2.2.1. Розробити будову програмної системи.
Основні компоненти архітектури програмної системи:
1. Клієнтський рівень:
   - Web Interface: React.js додаток для користувачів та адміністраторів
   - Mobile Apps: Нативні додатки для iOS та Android
2. API Gateway:
   - Єдина точка входу для всіх клієнтських запитів
   - Маршрутизація запитів до відповідних мікросервісів
   - Аутентифікація та авторизація
3. Сервісний рівень:
   - Auth Service: Керування користувачами та авторизацією
   - Order Service: Обробка замовлень та черги друку
   - Payment Service: Обробка платежів та управління гаманцями
   - Device Service: Керування вендинговими автоматами та IoT взаємодія
   - Analytics Service: Збір та аналіз даних

4. Persistence рівень:
   - PostgreSQL: Основне сховище даних
   - Redis Cache: Кешування та зберігання сесій
5. External Services:
   - PayPal API: Платіжний шлюз
   - AWS Services: Хмарна інфраструктура
6. IoT Device Layer:
   - Вендингові автомати з електронними замками
   - MQTT протокол для комунікації
   - Передача статусу та конфігурації принтера
Ця архітектура забезпечує:
•	Масштабованість через мікросервісну архітектуру
•	Надійність через використання перевірених технологій
•	Гнучкість у розширенні функціоналу
•	Безпеку через API Gateway
•	Високу продуктивність через кешування та оптимізацію даних
Для кращого сприйняття архітектури системи була створена діаграма архітектури.
 

Рисунок 1 – діаграма архітектури системи

2.2.2. Створити UML діаграму прецедентів для серверної частини системи.
Основні елементи діаграми:
Опис основних прецедентів:
1. Користувач:
   - Реєстрація та авторизація в системі
   - Створення та управління замовленнями друку
   - Оплата послуг та управління гаманцем
   - Відстеження статусу замовлень
   - Управління профілем
2. Адміністратор:
   - Моніторинг стану вендингових автоматів
   - Управління замовленнями та чергою друку
   - Перегляд статистики та аналітики
   - Управління користувачами системи
3. IoT пристрій:
   - Відправка статусу пристрою
   - Отримання та оновлення конфігурації
   - Керування електронним замком
4. Платіжна система:
   - Обробка платіжних транзакцій
   - Підтвердження успішності оплати

 
Рисунок 2 – UML діаграма прецедентів

2.2.3. Створити ER діаграму даних.
3. Створення ER діаграми даних
Розробимо ER діаграму, яка відображатиме структуру даних системи та зв'язки між сутностями.
Опис основних сутностей та їх призначення:
1. Users - інформація про користувачів системи:
   - Основна інформація про користувача
   - Облікові дані та контакти

2. UserRoles - ролі користувачів:
   - Зберігання ролей (клієнт, адміністратор)
   - Зв'язок з користувачем
3. Wallet - електронний гаманець:
   - Баланс користувача
   - Історія транзакцій
4. Orders - замовлення на друк:
   - Інформація про модель для друку
   - Налаштування друку
   - Вартість замовлення
5. OrderStatus - статуси замовлень:
   - Відстеження етапів виконання замовлення
   - Історія зміни статусів
6. Payments - платежі:
   - Інформація про оплату
   - Статус транзакції
7. VendingMachines - вендингові автомати:
   - Інформація про пристрій
   - Місцезнаходження
   - Статус активності
8. DeviceStatus - статус пристроїв:
   - Поточний стан пристрою
   - Телеметрія
9. PrinterConfig - конфігурація принтерів:
   - Налаштування принтера
   - Технічні характеристики
 
Рисунок 3 – ER діаграма даних

2.2.4. Розробити базу даних (БД) програмної системи.
4. Розробка бази даних програмної системи
На основі створеної ER діаграми, розробимо SQL скрипти для створення бази даних PostgreSQL.
Особливості реалізації бази даних:
1. Використання UUID як первинних ключів для кращої масштабованості
2. Створення ENUM типів для обмеження можливих значень статусів
3. Використання JSONB для зберігання гнучких структур даних
4. Додавання необхідних індексів для оптимізації запитів
5. Реалізація тригерів для автоматичного оновлення часових міток
6. Додавання обмежень для забезпечення цілісності даних
7. Каскадне видалення пов'язаних записів де це необхідно
База даних розроблена з урахуванням:
- Масштабованості
- Продуктивності
- Цілісності даних
- Зручності обслуговування
2.2.5. Створити діаграму структури БД.
Особливості структури бази даних:
1. Основні таблиці:
   - users: зберігання інформації про користувачів
   - user_roles: ролі користувачів у системі
   - wallets: електронні гаманці користувачів
   - vending_machines: інформація про вендингові автомати
   - orders: замовлення на друк
   - payments: платежі
2. Допоміжні таблиці:
   - printer_configs: конфігурації 3D-принтерів
   - device_statuses: статуси пристроїв
   - order_statuses: статуси замовлень
3. Типи даних enum:
   - user_role_enum: типи ролей користувачів
   - order_status_enum: статуси замовлень
   - payment_status_enum: статуси платежів
   - device_status_enum: статуси пристроїв
4. Зв'язки між таблицями:
   - Один користувач може мати багато замовлень
   - Один вендинговий автомат може обробляти багато замовлень
   - Кожне замовлення має багато статусів
   - Кожен пристрій має одну конфігурацію та багато статусів
 
Рисунок 4 – діаграма бази даних

2.2.6. Розробити функції роботи з БД.
Основні особливості реалізації:
1. Структура проекту:
   - Модульна архітектура з поділом на логічні компоненти
   - Окремі модулі для кожної основної сутності
   - Чітке розділення бізнес-логіки та доступу до даних
2. Entity класи:
   - Використання декораторів TypeORM
   - Визначення зв'язків між сутностями
   - Автоматичне оновлення часових міток
3. Сервісні класи:
   - Інжекція репозиторіїв
   - Базові CRUD операції
   - Обробка зв'язаних сутностей
4. Конфігурація бази даних:
   - Використання змінних середовища
   - Підтримка міграцій
   - Налаштування логування
Основні особливості реалізованих сервісів:
1. UsersService:
   - Управління користувачами та їх ролями
   - Базові CRUD операції
   - Пошук за email
2. VendingMachinesService:
   - Управління вендинговими автоматами
   - Відстеження статусу пристроїв
   - Конфігурація принтерів
3. OrdersService:
   - Створення та управління замовленнями
   - Відстеження статусу замовлень
   - Фільтрація за користувачем та пристроєм
4. PaymentsService:
   - Обробка платежів
   - Управління гаманцями користувачів
   - Відстеження балансу та транзакцій
Особливості реалізації:
- Використання TypeORM Repository для роботи з БД
- Обробка помилок та винятків
- Автоматичне оновлення статусів
- Підтримка зв'язків між сутностями
- Транзакційність операцій з гаманцем
2.2.7. Розробити API для взаємодії серверної частини з клієнтами.
Розробимо REST API з використанням NestJS. Для документації використаємо Swagger.
Основні ендпоінти API:
1. Users API:
   - POST /users - створення нового користувача
   - GET /users - отримання списку користувачів (тільки адмін)
   - GET /users/:id - отримання інформації про користувача
2. Orders API:
   - POST /orders - створення нового замовлення
   - GET /orders/my-orders - отримання замовлень користувача
   - GET /orders/:id - отримання інформації про замовлення
3. Vending Machines API:
   - GET /vending-machines - отримання списку автоматів
   - POST /vending-machines/:id/status - оновлення статусу автомату
4. Payments API:
   - POST /payments - створення нового платежу
   - GET /payments/wallet/balance - отримання балансу гаманця
   - POST /payments/wallet/topup - поповнення гаманця
Особливості реалізації:
- Swagger документація для всіх ендпоінтів
- Валідація вхідних даних
- Аутентифікація та авторизація
- Розділення прав доступу
- DTO для валідації запитів
2.2.8. Створити специфікацію розробленого API.
Розробимо OpenAPI (Swagger) специфікацію для нашого API.
Основні компоненти специфікації API:
1. Загальна інформація:
   - Версія API
   - Опис системи
   - Сервери для розробки та продакшн
2. Схеми даних:
   - User - користувачі системи
   - Order - замовлення
   - VendingMachine - вендингові автомати
   - Payment - платежі
   - DTO для створення об'єктів
3. Ендпоінти:
   - /users - управління користувачами
   - /orders - управління замовленнями
   - /vending-machines - управління автоматами
   - /payments - управління платежами
4. Безпека:
   - JWT автентифікація
   - Захист ендпоінтів
   - Права доступу
5. Відповіді:
   - Схеми успішних відповідей
   - Обробка помилок
   - HTTP статуси
Специфікація готова для використання в Swagger UI та може бути використана для генерації клієнтських бібліотек.
2.2.9. Створити програмну реалізацію розробленого API та функцій роботи з БД.
9. Створення програмної реалізації API та функцій роботи з БД
Розробимо основні компоненти для реалізації API в NestJS, а також реалізуємо MQTT сервіс для комунікації з IoT пристроями:
Основні компоненти реалізації:
1. Core компоненти:
   - Guards для авторизації
   - Декоратори для ролей та користувача
   - Interceptors для трансформації відповідей
   - Filters для обробки помилок
2. Конфігурація:
   - TypeORM налаштування
   - Змінні середовища
   - Swagger документація
3. Модулі:
   - AppModule як головний модуль
   - Окремі модулі для кожного компонента
   - MQTT сервіс для IoT комунікації
4. IoT комунікація:
   - MQTT підключення
   - Обробка статусів пристроїв
   - Керування електронними замками
   - Телеметрія
2.3 Висновки: під час лабораторної роботи була розроблена база даних для серверної частини програмної системи та прикладний програмний інтерфейс.
